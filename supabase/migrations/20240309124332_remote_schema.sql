
SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

CREATE SCHEMA IF NOT EXISTS "public";
ALTER SCHEMA "public" OWNER TO "pg_database_owner";
CREATE EXTENSION vector SCHEMA "public";

CREATE OR REPLACE FUNCTION "public"."create_profile"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$begin
  insert into public.profile(
    user_id,
    email,
    name,
    stripe_customer_id,
    subscription_status,
    price
  )

values (
  new.id,
  new.email,
 new.raw_user_meta_data->>'name',
new.raw_user_meta_data->>'stripe_customer_id',
new.raw_user_meta_data->>'subscription_status',
new.raw_user_meta_data->>'price'

);
  return new;
end;$$;

ALTER FUNCTION "public"."create_profile"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."match_documents"("query_embedding" "public"."vector", "file_id" "uuid", "match_count" integer DEFAULT NULL::integer, "filter" "jsonb" DEFAULT '{}'::"jsonb") RETURNS TABLE("id" bigint, "content" "text", "metadata" "jsonb", "similarity" double precision)
    LANGUAGE "plpgsql"
    AS $_$
BEGIN
  RETURN QUERY
  SELECT
    documents.id, -- Qualify 'id' with the table name to avoid ambiguity
    documents.content,
    documents.metadata,
    1 - (documents.embedding <=> query_embedding) AS similarity
  FROM documents
  WHERE documents.metadata @> filter
    AND documents.file_id = $2 -- Filter by file_id
  ORDER BY documents.embedding <=> query_embedding
  LIMIT match_count;
END;
$_$;

ALTER FUNCTION "public"."match_documents"("query_embedding" "public"."vector", "file_id" "uuid", "match_count" integer, "filter" "jsonb") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."match_preview"("query_embedding" "public"."vector", "match_count" integer DEFAULT NULL::integer, "filter" "jsonb" DEFAULT '{}'::"jsonb") RETURNS TABLE("id" bigint, "content" "text", "metadata" "jsonb", "similarity" double precision)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    preview.id, -- Qualify 'id' with the table name to avoid ambiguity
    preview.content,
    preview.metadata,
    1 - (preview.embedding <=> query_embedding) AS similarity
  FROM preview
  WHERE preview.metadata @> filter
  ORDER BY preview.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

ALTER FUNCTION "public"."match_preview"("query_embedding" "public"."vector", "match_count" integer, "filter" "jsonb") OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";

CREATE TABLE IF NOT EXISTS "public"."chats" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE "public"."chats" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."documents" (
    "id" bigint NOT NULL,
    "content" "text",
    "metadata" "jsonb",
    "embedding" "public"."vector"(1536),
    "user_id" "uuid",
    "file_id" "uuid",
    "chat_id" "uuid"
);

ALTER TABLE "public"."documents" OWNER TO "postgres";

CREATE SEQUENCE IF NOT EXISTS "public"."documents_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;

ALTER TABLE "public"."documents_id_seq" OWNER TO "postgres";

ALTER SEQUENCE "public"."documents_id_seq" OWNED BY "public"."documents"."id";

CREATE TABLE IF NOT EXISTS "public"."messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "question" "text"[],
    "answer" "text"[],
    "sent_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "chatId" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL
);

ALTER TABLE "public"."messages" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."pdfs" (
    "id" bigint NOT NULL,
    "text" "text"[] NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "chatId" "uuid" DEFAULT "gen_random_uuid"(),
    "userId" "uuid",
    "file_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "pdf_title" "text" DEFAULT ''::"text"
);

ALTER TABLE "public"."pdfs" OWNER TO "postgres";

ALTER TABLE "public"."pdfs" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."pdfs_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."preview" (
    "id" bigint NOT NULL,
    "content" "text",
    "metadata" "jsonb",
    "embedding" "public"."vector"(1536)
);

ALTER TABLE "public"."preview" OWNER TO "postgres";

CREATE SEQUENCE IF NOT EXISTS "public"."preview_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;

ALTER TABLE "public"."preview_id_seq" OWNER TO "postgres";

ALTER SEQUENCE "public"."preview_id_seq" OWNED BY "public"."preview"."id";

CREATE TABLE IF NOT EXISTS "public"."profile" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "name" "text",
    "email" "text",
    "stripe_customer_id" "text",
    "subscription_status" "text",
    "price" "text",
    "user_id" "uuid" NOT NULL
);

ALTER TABLE "public"."profile" OWNER TO "postgres";

ALTER TABLE "public"."profile" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."profile_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

ALTER TABLE ONLY "public"."documents" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."documents_id_seq"'::"regclass");

ALTER TABLE ONLY "public"."preview" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."preview_id_seq"'::"regclass");

ALTER TABLE ONLY "public"."chats"
    ADD CONSTRAINT "chats_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."documents"
    ADD CONSTRAINT "documents_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_user_id_key" UNIQUE ("user_id");

ALTER TABLE ONLY "public"."pdfs"
    ADD CONSTRAINT "pdfs_file_id_key" UNIQUE ("file_id");

ALTER TABLE ONLY "public"."pdfs"
    ADD CONSTRAINT "pdfs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."preview"
    ADD CONSTRAINT "preview_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."profile"
    ADD CONSTRAINT "profile_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."profile"
    ADD CONSTRAINT "profile_user_id_key" UNIQUE ("user_id");

ALTER TABLE ONLY "public"."documents"
    ADD CONSTRAINT "documents_chat_id_fkey" FOREIGN KEY ("chat_id") REFERENCES "public"."chats"("id");

ALTER TABLE ONLY "public"."documents"
    ADD CONSTRAINT "documents_file_id_fkey" FOREIGN KEY ("file_id") REFERENCES "storage"."objects"("id");

ALTER TABLE ONLY "public"."documents"
    ADD CONSTRAINT "documents_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_chatId_fkey" FOREIGN KEY ("chatId") REFERENCES "public"."chats"("id");

ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."pdfs"
    ADD CONSTRAINT "pdfs_chatId_fkey" FOREIGN KEY ("chatId") REFERENCES "public"."chats"("id");

ALTER TABLE ONLY "public"."pdfs"
    ADD CONSTRAINT "pdfs_file_id_fkey" FOREIGN KEY ("file_id") REFERENCES "storage"."objects"("id");

ALTER TABLE ONLY "public"."pdfs"
    ADD CONSTRAINT "pdfs_userId_fkey" FOREIGN KEY ("userId") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."profile"
    ADD CONSTRAINT "profile_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

CREATE POLICY "Enable delete for users based on user_id" ON "public"."messages" FOR DELETE TO "authenticated" USING (("auth"."uid"() = "user_id"));

CREATE POLICY "Enable insert for authenticated users only" ON "public"."chats" FOR SELECT USING (true);

CREATE POLICY "Enable insert for authenticated users only" ON "public"."documents" FOR INSERT TO "authenticated" WITH CHECK (true);

CREATE POLICY "Enable insert for authenticated users only" ON "public"."messages" FOR INSERT TO "authenticated" WITH CHECK (true);

CREATE POLICY "Enable insert for authenticated users only" ON "public"."pdfs" FOR INSERT TO "authenticated" WITH CHECK (true);

CREATE POLICY "Enable insert for users based on user_id" ON "public"."documents" FOR INSERT WITH CHECK (true);

CREATE POLICY "Enable insert for users based on user_id" ON "public"."pdfs" FOR INSERT WITH CHECK (true);

CREATE POLICY "Enable insert for users based on user_id" ON "public"."profile" FOR INSERT WITH CHECK (true);

CREATE POLICY "Enable read access for all users" ON "public"."chats" FOR INSERT WITH CHECK (true);

CREATE POLICY "Enable read access for all users" ON "public"."documents" FOR SELECT USING (true);

CREATE POLICY "Enable read access for all users" ON "public"."pdfs" FOR SELECT USING (true);

CREATE POLICY "Enable read access for all users" ON "public"."preview" FOR SELECT USING (true);

CREATE POLICY "Enable read access for all users" ON "public"."profile" FOR SELECT USING (true);

CREATE POLICY "Enable select for authenticated users only" ON "public"."messages" FOR SELECT TO "authenticated" USING (true);

CREATE POLICY "Enable update for users based on email" ON "public"."profile" FOR UPDATE USING ((("auth"."jwt"() ->> 'email'::"text") = "email")) WITH CHECK ((("auth"."jwt"() ->> 'email'::"text") = "email"));

CREATE POLICY "Enable update for users based on id" ON "public"."messages" FOR UPDATE USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));

ALTER TABLE "public"."chats" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."documents" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."messages" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."pdfs" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."profile" ENABLE ROW LEVEL SECURITY;

REVOKE USAGE ON SCHEMA "public" FROM PUBLIC;
GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

GRANT ALL ON FUNCTION "public"."create_profile"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_profile"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_profile"() TO "service_role";

GRANT ALL ON FUNCTION "public"."match_documents"("query_embedding" "public"."vector", "file_id" "uuid", "match_count" integer, "filter" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."match_documents"("query_embedding" "public"."vector", "file_id" "uuid", "match_count" integer, "filter" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."match_documents"("query_embedding" "public"."vector", "file_id" "uuid", "match_count" integer, "filter" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."match_preview"("query_embedding" "public"."vector", "match_count" integer, "filter" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."match_preview"("query_embedding" "public"."vector", "match_count" integer, "filter" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."match_preview"("query_embedding" "public"."vector", "match_count" integer, "filter" "jsonb") TO "service_role";

GRANT ALL ON TABLE "public"."chats" TO "anon";
GRANT ALL ON TABLE "public"."chats" TO "authenticated";
GRANT ALL ON TABLE "public"."chats" TO "service_role";

GRANT ALL ON TABLE "public"."documents" TO "anon";
GRANT ALL ON TABLE "public"."documents" TO "authenticated";
GRANT ALL ON TABLE "public"."documents" TO "service_role";

GRANT ALL ON SEQUENCE "public"."documents_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."documents_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."documents_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."messages" TO "anon";
GRANT ALL ON TABLE "public"."messages" TO "authenticated";
GRANT ALL ON TABLE "public"."messages" TO "service_role";

GRANT ALL ON TABLE "public"."pdfs" TO "anon";
GRANT ALL ON TABLE "public"."pdfs" TO "authenticated";
GRANT ALL ON TABLE "public"."pdfs" TO "service_role";

GRANT ALL ON SEQUENCE "public"."pdfs_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."pdfs_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."pdfs_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."preview" TO "anon";
GRANT ALL ON TABLE "public"."preview" TO "authenticated";
GRANT ALL ON TABLE "public"."preview" TO "service_role";

GRANT ALL ON SEQUENCE "public"."preview_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."preview_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."preview_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."profile" TO "anon";
GRANT ALL ON TABLE "public"."profile" TO "authenticated";
GRANT ALL ON TABLE "public"."profile" TO "service_role";

GRANT ALL ON SEQUENCE "public"."profile_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."profile_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."profile_id_seq" TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "service_role";

RESET ALL;
